from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends
from sqlalchemy.orm import Session
from datetime import datetime
import json
import os
import database, models
from services import rag_service, pdf_service
from connection_manager import manager

STORAGE_ROOT = "storage"

router = APIRouter(
    tags=["websocket"]
)

@router.websocket("/ws/generate-quiz/{client_id}")
async def websocket_quiz_endpoint(websocket: WebSocket, client_id: str, db: Session = Depends(database.get_db)):
    await manager.connect(websocket, client_id)
    try:
        while True:
            # Wait for "start_generation" message
            data = await websocket.receive_text()
            message = json.loads(data)
            
            if message.get("action") == "generate":
                params = message.get("params", {})
                
                # Extract params
                topic = params.get("topic")
                grade_level = params.get("grade_level")
                difficulty = params.get("difficulty")
                question_count = int(params.get("question_count", 5))
                subject_id = int(params.get("subject_id"))
                class_id = int(params.get("class_id"))
                teacher_id = int(params.get("teacher_id")) # Or from session/token if we did auth
                
                # 1. Get Subject Name
                subject = db.query(models.Subject).filter(models.Subject.id == subject_id).first()
                subject_name = subject.name if subject else "General Knowledge"
                
                # Progress Callback Wrapper
                async def progress_callback(status: str, details: dict):
                    await manager.send_json({
                        "type": "progress",
                        "status": status,
                        "details": details
                    }, client_id)
                    # Small delay to let UI breathe if needed?
                    # await asyncio.sleep(0.1)

                await manager.send_json({"type": "info", "message": f"Starting generation for {topic} ({subject_name})..."}, client_id)
                
                # 2. Call RAG
                generated_questions = await rag_service.generate_quiz_questions(
                    topic=topic,
                    subject_name=subject_name,
                    grade_level=grade_level,
                    difficulty=difficulty,
                    count=question_count,
                    progress_callback=progress_callback
                )
                
                if generated_questions:
                    # 3. Create Assignment in DB
                    title = f"Quiz: {topic}"
                    description = f"A {difficulty} level quiz about {topic}. Generated by AI."
                    
                    new_assignment = models.Assignment(
                        title=title,
                        description=description,
                        status=models.AssignmentStatus.DRAFT,
                        teacher_id=teacher_id,
                        subject_id=subject_id,
                        class_id=class_id,
                        due_date=datetime.utcnow() # Default
                    )
                    db.add(new_assignment)
                    db.commit()
                    db.refresh(new_assignment)
                    
                    # 4. Create Questions
                    for q_data in generated_questions:
                        q_type_str = q_data.get("question_type", "MULTIPLE_CHOICE")
                        try:
                            q_type = models.QuestionType(q_type_str)
                        except:
                            q_type = models.QuestionType.MULTIPLE_CHOICE
                            
                        new_q = models.Question(
                            text=q_data.get("text", "Question Text"),
                            points=q_data.get("points", 5),
                            question_type=q_type,
                            assignment_id=new_assignment.id
                        )
                        db.add(new_q)
                        db.commit()
                        db.refresh(new_q)
                        
                        for opt in q_data.get("options", []):
                            new_opt = models.QuestionOption(
                                text=opt.get("text", ""),
                                is_correct=opt.get("is_correct", False),
                                question_id=new_q.id
                            )
                            db.add(new_opt)
                    
                    db.commit()
                    
                    # Send result
                    await manager.send_json({
                        "type": "completed", 
                        "message": "Quiz generated successfully!",
                        "assignment_id": new_assignment.id
                    }, client_id)
                else:
                    await manager.send_json({
                        "type": "error", 
                        "message": "Failed to generate questions."
                    }, client_id)
            
    except WebSocketDisconnect:
        manager.disconnect(client_id)
    except Exception as e:
        print(f"WS Error: {e}")
        try:
             await manager.send_json({"type": "error", "message": f"Server Error: {str(e)}"}, client_id)
        except:
            pass
        manager.disconnect(client_id)

@router.websocket("/ws/training/{file_id}")
async def websocket_train_file(websocket: WebSocket, file_id: int, db: Session = Depends(database.get_db)):
    await websocket.accept()
    
    try:
        # Fetch file details
        artifact = db.query(models.FileArtifact).filter(models.FileArtifact.id == file_id).first()
        if not artifact:
            await websocket.send_text("Error: File not found")
            await websocket.close()
            return
            
        await websocket.send_text(f"Starting training process for: {artifact.original_filename}")
        
        # Resolve Path
        base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) # pointing to backend/
        file_path = os.path.join(base_dir, STORAGE_ROOT, artifact.relative_path)
        
        if not os.path.exists(file_path):
             await websocket.send_text(f"Error: File not found on disk at {file_path}")
             await websocket.close()
             return

        # Prepare Metadata
        user_metadata = {}
        if artifact.file_metadata:
                try:
                    user_metadata = json.loads(artifact.file_metadata)
                except:
                    pass

        rag_metadata = {
            "file_id": artifact.id,
            "school_id": artifact.school_id,
            "grade_id": artifact.grade_id,
            "subject_id": artifact.subject_id,
            "filename": artifact.original_filename,
            **user_metadata 
        }

        # Step 1: Parse PDF
        await websocket.send_text("Step 1: Parsing PDF...")
        # Note: pdf_service is sync, run in threadpool to avoid blocking event loop
        # But for simplicity in this demo, calling it directly (it's fast enough or blocks briefly)
        # Better: chunks = await asyncio.to_thread(pdf_service.parse_pdf, file_path)
        chunks = pdf_service.parse_pdf(file_path) 
        await websocket.send_text(f"Parsed {len(chunks)} chunks from PDF.")
        
        # Step 2: RAG Pipeline (Async)
        await websocket.send_text("Step 2: Starting Classification and Embedding Pipeline...")
        
        # Define callback to send messages to WS
        async def ws_callback(msg: str):
            await websocket.send_text(msg)
            
        await rag_service.process_chunks_async(chunks, rag_metadata, progress_callback=ws_callback)
        
        # Step 3: Update Status to Trained
        # Re-fetch artifact to ensure session is valid or use merge
        # artifact.file_status = "Trained"
        # db.commit()
        # Updating via new query to avoid session detach issues in long async
        db.query(models.FileArtifact).filter(models.FileArtifact.id == file_id).update({"file_status": "Trained"})
        db.commit()
        
        await websocket.send_text("DONE")
        
    except WebSocketDisconnect:
        print(f"Client disconnected for file {file_id}")
    except Exception as e:
        await websocket.send_text(f"Error: {str(e)}")
        print(f"Error in WS training: {e}")
    finally:
        try:
            await websocket.close()
        except:
            pass
