from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends
from sqlalchemy.orm import Session
from datetime import datetime
import json
import database, models
from services import rag_service
from connection_manager import manager

router = APIRouter(
    tags=["websocket"]
)

@router.websocket("/ws/generate-quiz/{client_id}")
async def websocket_quiz_endpoint(websocket: WebSocket, client_id: str, db: Session = Depends(database.get_db)):
    await manager.connect(websocket, client_id)
    try:
        while True:
            # Wait for "start_generation" message
            data = await websocket.receive_text()
            message = json.loads(data)
            
            if message.get("action") == "generate":
                params = message.get("params", {})
                
                # Extract params
                topic = params.get("topic")
                grade_level = params.get("grade_level")
                difficulty = params.get("difficulty")
                question_count = int(params.get("question_count", 5))
                subject_id = int(params.get("subject_id"))
                class_id = int(params.get("class_id"))
                teacher_id = int(params.get("teacher_id")) # Or from session/token if we did auth
                
                # 1. Get Subject Name
                subject = db.query(models.Subject).filter(models.Subject.id == subject_id).first()
                subject_name = subject.name if subject else "General Knowledge"
                
                # Progress Callback Wrapper
                async def progress_callback(status: str, details: dict):
                    await manager.send_json({
                        "type": "progress",
                        "status": status,
                        "details": details
                    }, client_id)
                    # Small delay to let UI breathe if needed?
                    # await asyncio.sleep(0.1)

                await manager.send_json({"type": "info", "message": f"Starting generation for {topic} ({subject_name})..."}, client_id)
                
                # 2. Call RAG
                generated_questions = await rag_service.generate_quiz_questions(
                    topic=topic,
                    subject_name=subject_name,
                    grade_level=grade_level,
                    difficulty=difficulty,
                    count=question_count,
                    progress_callback=progress_callback
                )
                
                if generated_questions:
                    # 3. Create Assignment in DB
                    title = f"Quiz: {topic}"
                    description = f"A {difficulty} level quiz about {topic}. Generated by AI."
                    
                    new_assignment = models.Assignment(
                        title=title,
                        description=description,
                        status=models.AssignmentStatus.DRAFT,
                        teacher_id=teacher_id,
                        subject_id=subject_id,
                        class_id=class_id,
                        due_date=datetime.utcnow() # Default
                    )
                    db.add(new_assignment)
                    db.commit()
                    db.refresh(new_assignment)
                    
                    # 4. Create Questions
                    for q_data in generated_questions:
                        q_type_str = q_data.get("question_type", "MULTIPLE_CHOICE")
                        try:
                            q_type = models.QuestionType(q_type_str)
                        except:
                            q_type = models.QuestionType.MULTIPLE_CHOICE
                            
                        new_q = models.Question(
                            text=q_data.get("text", "Question Text"),
                            points=q_data.get("points", 5),
                            question_type=q_type,
                            assignment_id=new_assignment.id
                        )
                        db.add(new_q)
                        db.commit()
                        db.refresh(new_q)
                        
                        for opt in q_data.get("options", []):
                            new_opt = models.QuestionOption(
                                text=opt.get("text", ""),
                                is_correct=opt.get("is_correct", False),
                                question_id=new_q.id
                            )
                            db.add(new_opt)
                    
                    db.commit()
                    
                    # Send result
                    await manager.send_json({
                        "type": "completed", 
                        "message": "Quiz generated successfully!",
                        "assignment_id": new_assignment.id
                    }, client_id)
                else:
                    await manager.send_json({
                        "type": "error", 
                        "message": "Failed to generate questions."
                    }, client_id)
            
    except WebSocketDisconnect:
        manager.disconnect(client_id)
    except Exception as e:
        print(f"WS Error: {e}")
        try:
             await manager.send_json({"type": "error", "message": f"Server Error: {str(e)}"}, client_id)
        except:
            pass
        manager.disconnect(client_id)
